# 安全和可靠性检查清单

## 输入/输出安全

- **XSS**：不安全的 HTML 注入、`dangerouslySetInnerHTML`、未转义的模板、innerHTML 赋值
- **注入**：通过字符串连接或模板字面量的 SQL/NoSQL/命令/GraphQL 注入
- **SSRF**：用户控制的 URL 到达内部服务而没有白名单验证
- **路径遍历**：文件路径中的用户输入未经清理（`../` 攻击）
- **原型污染**：JavaScript 中不安全的对象合并（`Object.assign`、使用用户输入的展开）

## 认证/授权

- 读/写操作缺失租户或所有权检查
- 新端点没有认证守卫或 RBAC 执行
- 信任客户端提供的角色/标记/ID
- 访问控制损坏（IDOR - 不安全的直接对象引用）
- 会话固定或弱会话管理

## JWT 和令牌安全

- 算法混淆攻击（当期望 `RS256` 时接受 `none` 或 `HS256`）
- 弱或硬编码的密钥
- 缺失过期时间（`exp`）或不验证它
- JWT 负载中的敏感数据（令牌是 base64，不是加密）
- 不验证 `iss`（发行者）或 `aud`（受众）

## 密钥和 PII

- 代码/配置/日志中的 API 密钥、令牌或凭据
- git 历史中的密钥或暴露给客户端的环境变量
- PII 或敏感负载的过度日志记录
- 错误消息中缺失数据掩码

## 供应链与依赖

- 未固定的依赖允许恶意更新
- 依赖混淆（私有包名冲突）
- 从不受信任的来源或没有完整性检查的 CDN 导入
- 具有已知 CVE 的过时依赖

## CORS 和标头

- 过于宽松的 CORS（带凭据的 `Access-Control-Allow-Origin: *`）
- 缺失安全标头（CSP、X-Frame-Options、X-Content-Type-Options）
- 暴露的内部标头或堆栈跟踪

## 运行时风险

- 无界循环、递归调用或大型内存缓冲区
- 外部调用缺失超时、重试或速率限制
- 请求路径上的阻塞操作（异步上下文中的同步 I/O）
- 资源耗尽（文件句柄、连接、内存）
- ReDoS（正则表达式拒绝服务）

## 加密

- 弱算法（用于安全目的的 MD5、SHA1）
- 硬编码的 IV 或盐
- 使用没有认证的加密（ECB 模式、无 HMAC）
- 不足的密钥长度

## 竞态条件

竞态条件是导致间歇性失败和安全漏洞的微妙错误。特别注意：

### 共享状态访问
- 多个线程/goroutine/异步任务在没有同步的情况下访问共享变量
- 全局状态或单例被并发修改
- 没有适当锁定的延迟初始化（双重检查锁定问题）
- 在并发上下文中使用非线程安全的集合

### 检查后操作（TOCTOU）
- `if (exists) then use` 模式没有原子操作
- `if (authorized) then perform` 其中授权可以更改
- 文件存在检查后跟文件操作
- 余额检查后跟扣除（金融操作）
- 库存检查后跟订单下单

### 数据库并发

- 缺失乐观锁定（`version` 列、`updated_at` 检查）
- 缺失悲观锁定（`SELECT FOR UPDATE`）
- 没有事务隔离的读-修改-写
- 没有原子操作的计数器增量（`UPDATE SET count = count + 1`）
- 并发插入中的唯一约束违规

### 分布式系统

- 共享资源缺失分布式锁
- 领导者选举竞态条件
- 缓存失效竞争（写入后的陈旧读取）
- 没有适当排序的事件顺序依赖
- 集群操作中的脑裂场景

### 要标记的常见模式
```
# 危险模式：
if not exists(key):       # TOCTOU
    create(key)

value = get(key)          # 读-修改-写
value += 1
set(key, value)

if user.balance >= amount:  # 检查后操作
    user.balance -= amount
```

### 要问的问题
- "如果两个请求同时命中这段代码会发生什么？"
- "这个操作是原子的还是可以被中断？"
- "这段代码访问什么共享状态？"
- "在高并发下这如何表现？"

## 数据完整性

- 缺失事务、部分写入或不一致的状态更新
- 持久化前的弱验证（类型强制问题）
- 可重试操作缺失幂等性
- 由于并发修改导致的更新丢失
