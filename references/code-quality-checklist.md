# 代码质量检查清单

## 错误处理

### 要标记的反模式

- **吞咽异常**：空的 catch 块或仅记录日志的 catch
  ```javascript
  try { ... } catch (e) { }  // 静默失败
  try { ... } catch (e) { console.log(e) }  // 记录后忘记
  ```
- **过于宽泛的捕获**：捕获 `Exception`/`Error` 基类而不是特定类型
- **错误信息泄露**：将堆栈跟踪或内部详情暴露给用户
- **缺失错误处理**：易失败的操作（I/O、网络、解析）周围没有 try-catch
- **异步错误处理**：未处理的 promise 拒绝、缺失 `.catch()`、没有错误边界

### 要检查的最佳实践

- [ ] 在适当的边界处捕获错误
- [ ] 错误消息对用户友好（不暴露内部详情）
- [ ] 记录错误时包含足够的上下文用于调试
- [ ] 异步错误被正确传播或处理
- [ ] 为可恢复的错误定义了回退行为
- [ ] 严重错误触发警报/监控

### 要问的问题
- "当此操作失败时会发生什么？"
- "调用者会知道出了问题吗？"
- "是否有足够的上下文来调试此错误？"

---

## 性能与缓存

### CPU 密集型操作

- **热路径中的昂贵操作**：在循环中进行正则表达式编译、JSON 解析、加密
- **阻塞主线程**：同步 I/O、没有 worker/async 的重度计算
- **不必要的重复计算**：多次进行相同的计算
- **缺失记忆化**：纯函数使用相同输入重复调用

### 数据库与 I/O

- **N+1 查询**：循环中每个项目都进行查询而不是批处理
  ```javascript
  // 坏：N+1
  for (const id of ids) {
    const user = await db.query(`SELECT * FROM users WHERE id = ?`, id)
  }
  // 好：批处理
  const users = await db.query(`SELECT * FROM users WHERE id IN (?)`, ids)
  ```
- **缺失索引**：在未建索引的列上查询
- **过度获取**：只需要几列时使用 SELECT *
- **无分页**：将整个数据集加载到内存

### 缓存问题

- **昂贵操作缺失缓存**：重复的 API 调用、数据库查询、计算
- **没有 TTL 的缓存**：无限期地提供陈旧数据
- **没有失效策略的缓存**：数据已更新但缓存未清除
- **缓存键冲突**：键唯一性不足
- **全局缓存用户特定数据**：安全/隐私问题

### 内存

- **无界集合**：无限制增长的数组/映射
- **大对象保留**：持有引用阻止 GC
- **循环中的字符串连接**：使用 StringBuilder/join 代替
- **完整加载大文件**：使用流式处理代替

### 要问的问题
- "这个操作的时间复杂度是多少？"
- "在 10 倍/100 倍数据量下这会如何表现？"
- "这个结果可缓存吗？应该缓存吗？"
- "这可以批处理而不是逐个处理吗？"

---

## 边界条件

### Null/Undefined 处理

- **缺失空值检查**：访问可能为空的对象的属性
- **真值/假值混淆**：当 `0` 或 `""` 是有效值时使用 `if (value)`
- **过度使用可选链**：`a?.b?.c?.d` 隐藏结构问题
- **Null vs undefined 不一致**：混合使用没有明确约定

### 空集合

- **未处理空数组**：代码假定数组有项目
- **空对象边界情况**：在空对象上使用 `for...in` 或 `Object.keys`
- **首/尾元素访问**：`arr[0]` 或 `arr[arr.length-1]` 没有长度检查

### 数值边界

- **除以零**：除法前缺失检查
- **整数溢出**：大数超出安全整数范围
- **浮点比较**：使用 `===` 而不是 epsilon 比较
- **负值**：索引或计数不应为负
- **差一错误**：循环边界、数组切片、分页

### 字符串边界

- **空字符串**：未作为边界情况处理
- **仅空白字符串**：通过真值检查但实际为空
- **非常长的字符串**：没有长度限制导致内存/显示问题
- **Unicode 边界情况**：表情符号、RTL 文本、组合字符

### 要标记的常见模式

```javascript
// 危险：无空值检查
const name = user.profile.name

// 危险：无检查的数组访问
const first = items[0]

// 危险：无检查的除法
const avg = total / count

// 危险：真值检查排除有效值
if (value) { ... }  // 对 0、""、false 失败
```

### 要问的问题
- "如果这是 null/undefined 会怎样？"
- "如果这个集合是空的会怎样？"
- "这个数字的有效范围是什么？"
- "在边界处（0、-1、MAX_INT）会发生什么？"
